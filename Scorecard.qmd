---
title: "<center> Modelo de riesgo de crédito</center>"
author: "Valentina Vanegas Castaño <br> Edwar Jose Londoño Correa <br> Andres Castrillón Velasquez <br> Diego Andres Chavarria Riaño <br> Sebastian Rendon Arteaga"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,message = F,warning = F)
```

```{r}
#install.packages('ROSE')
#install.packages('scorecard')
library(ROSE)
library(scorecard)
library(pander)
library(kableExtra)
```

## 1- Contexto del problema

Los bancos al ser prestamistas , poseen el riesgo de tener perdidas con los créditos dado ya que pueden exisitir clientes que sean morosos con los pagos. Se desea crear un modelo que permita predecir, mediante un score calculado con la información del usuario que posee el crédito, la probabilidad de incumplimiento de sus obligaciones financieras en los siguientes 12 meses a la fecha de originación de su crédito. Este modelo ayudaría en a los bancos en sus tomas de decisiones sobre sus clientes. Para la creación del modelo, se uso utilizó un trabajo realizado por Ng Yong Kad (2020), y también la documentación sobre la librería scorecard obtenida por CRAN (2022).

Para la creación del modelo, se utiliza un dataset que posee 45 variables y 466285 registros.

```{r}
# Se carga el dataset
d1<- read.csv("loan_data_2007_2014-1.csv", encoding = "UTF-8")
d2<- read.csv("loan_data_2007_2014-2.csv", encoding = "UTF-8")
d3<- read.csv("loan_data_2007_2014-3.csv", encoding = "UTF-8")
daux<- rbind(d1,d2)
data <- rbind(daux,d3)
```

## 2- Procesamiento de los datos

Inicialmente se eliminan variables que poseen un gran número o en su totalidad valores representados con N/A. También se eliminan variables que no son predictoras, como las variables de identificación, url de una página, entre otras.

Teniendo en cuenta lo anterior, se eliminan las variables : dti_joint, open_il_6m, open_il_24m, total_bal_il, open_rv_12m, max_bal_bc, total_cu_tl, annual_inc_joint, verification_status_joint, open_acc_6m, open_il_12m, mths_since_rcnt_il, il_util, open_rv_24m, all_util, inq_fi, inq_last_12m,id, member_id, url, desc, zip_code, application_type, policy_code, mths_since_last_delinq, mths_since_last_record, mths_since_last_major_derog, tot_coll_amt, tot_cur_bal, total_rev_hi_lim.

```{r}
# Se eliminan algunas variables
data <- subset(data,select = -c(dti_joint, open_il_6m, open_il_24m, total_bal_il, open_rv_12m, max_bal_bc, total_cu_tl, annual_inc_joint, verification_status_joint, open_acc_6m, open_il_12m, mths_since_rcnt_il, il_util, open_rv_24m, all_util, inq_fi, inq_last_12m, id, url, desc, zip_code, application_type, member_id, policy_code, addr_state, sub_grade, emp_title, issue_d, title, mths_since_last_delinq, mths_since_last_record, mths_since_last_major_derog, tot_coll_amt, tot_cur_bal, total_rev_hi_lim))
```

Adicionalmente, en el dataset tenemos variables de tipo numéricas y de tipo character, para facilidad en el trabajo, se cambian las variables de tipo character a factor.

```{r}
# Se transforman las variables de tipo character a factor.
data$term <- as.factor(data$term)
data$grade <- as.factor(data$grade)
data$emp_length <- as.factor(data$emp_length)
data$verification_status <- as.factor(data$verification_status)
data$loan_status <- as.factor(data$loan_status)
data$pymnt_plan <- as.factor(data$pymnt_plan)
data$purpose <- as.factor(data$purpose)
data$initial_list_status <- as.factor(data$initial_list_status)
data$home_ownership <- as.factor(data$home_ownership)
```

```{r}
# Se divide el dataset por el tipo de variable.
variables_num <- sapply(data, is.numeric)
data_num <- data[variables_num]
variables_cat <- sapply(data, is.factor)
data_cat <- data[variables_cat]
#Se separa la variable loan_status de las demás variables categóricas.
Y<- subset(data_cat, select = loan_status)
data_cat <- subset(data_cat, select = -c(loan_status))
```

### 2.1- Análisis de Variables numéricas

Se modifican los valores de las variables numéricas que posean pocos valores N/A, por el valor de la mediana de cada atributo.

```{r}
data_num$annual_inc[is.na(data_num$annual_inc)] <- 63000
data_num$delinq_2yrs[is.na(data_num$delinq_2yrs)] <- 0.0000
data_num$inq_last_6mths[is.na(data_num$inq_last_6mths)] <- 0.0000
data_num$open_acc[is.na(data_num$open_acc)] <- 10.00
data_num$pub_rec[is.na(data_num$pub_rec)] <- 0.0000
data_num$revol_util[is.na(data_num$revol_util)] <- 57.60
data_num$total_acc[is.na(data_num$total_acc)] <- 23.00
data_num$collections_12_mths_ex_med[is.na(data_num$collections_12_mths_ex_med)] <- 0.0000
data_num$acc_now_delinq[is.na(data_num$acc_now_delinq)] <- 0.000000

```

También se analiza la existencia de datos atípicos en las variables numéricas. Para esto se crea una función que permita identificar las variables que poseen datos atípicos, y estos se escalan de la siguiente forma:

-   Los que se encuentran por encima del rango máximo, se escalan al percentil 95.

-   Los que se encuentran debajo del mínimo, se escalan al percentil 5.

```{r}
#Función para imprimir boxplots de todas las variables de un dataframe.
impre_box <- function(data){
  nombres <- names(data)
  dimen <- dim(data)[2]
  vector <- 1:dimen
  for (variable in vector) {
    plot.new()
    set.seed(1)
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
     col = "#ebebeb")
    grid(nx = NULL, ny = NULL, col = "white", lty = 1,
    lwd = par("lwd"), equilogs = TRUE)
    par(new = TRUE)
    boxplot(data[,variable], 
            main= nombres[variable],
            col = "#177e89",
            boxlty = 0,
            border = "#084c61",
            outpch = 25,      
            outbg = "#db3a34",   
            whisklty = 2,
            xlab= paste("Figura ",variable,". Boxplot de la variable ",nombres[variable])
            )
    #print(paste("Figura ",variable,". Boxplot de la variable ",nombres[variable]))
  }
}

#Función para cambiar valores outliers.
eliminacion_out <- function(data){

  dimen <- dim(data)[2]
  
  if(dimen == 1){
    vector <- c(1)  
  }else{
    vector <- 1:dimen
  }
  for (variable in vector){
    x <- data[,variable]   
    qnt <- quantile(x, probs=c(.25, .75), na.rm = T)
    caps <- quantile(x, probs=c(.05, .95), na.rm = T)
    H <- 1.5 * IQR(x, na.rm = T)
    x[x < (qnt[1] - H)] <- caps[1]
    x[x > (qnt[2] + H)] <- caps[2]
    
    data[,variable] <- x
  }
  return(data)
}

#Se aplican la función eliminacion_out() a las variables numéricas.
data_num <- eliminacion_out(data_num)
```

Al realizar lo anterior, identificamos la modificación los valores outliers en los siguientes boxplots para cada variable numérica.

```{r}
impre_box(data_num)
```

### 2.2- Modificación de la variable objetivo

En el dataset, la variable objetivo es la columna **"loan_status"**, en esta se encuentran los siguientes valores:

-   Current

-   Fully Paid.

-   Late (31-120 days).

-   In Grace Period.

-   Does not meet the credit policy. Status:Fully Paid.

-   Late (16-30 days).

-   Default.

-   Does not meet the credit policy. Status:Charged Off.

Para la creación de este modelo, las variables **"Default"** y **"Late (31-120 days)"** serán clasificadas como **"Cumple"**, y las demás como **"Incumple"**.

```{r}
#función para la transformación de la variable loan_status
transformacion_varialeObjetivo <- function(valor){
  valor_nuevo <- ""
  if ((as.character(valor) == "Late (31-120 days)") | (as.character(valor) == "Default")){
    valor_nuevo <- "Incumple"
  }else{
    valor_nuevo <- "Cumple"
  }
  return(valor_nuevo)
}

#Se aplica la función creada a la variable loan_status.
Y$loan_status <- sapply(Y$loan_status,transformacion_varialeObjetivo)
Y$loan_status <- as.factor(Y$loan_status)
```

En la Tabla 1, se observa la cantidad de registros que poseen calificación **"Cumple"** e **"Incumple"**.

```{r}
conteo_y= dplyr::count(Y, Y$loan_status, sort = TRUE)
colnames(conteo_y) <- c('Variable objetivo loan_status','Cantidad')

kable(conteo_y,caption = "Cantidad de registros categorizados") %>% 
  kable_styling(full_width = F,position = "center") %>% 
  kable_minimal()
```

```{r}
print("Tabla 1. Tabla del conteo de la variable loan_status")
```

```{r}
#Se unen los datos numéricos con los datos categóricos
datos <- cbind(data_num,data_cat,Y)
```

Debido al desbalanceo que se presenta en los registros, se utiliza una función de la librería ROSE, que permite realizar un balanceo en el dataset,. En la Tabla 2, se observa lo anterior:

```{r}
#Balanceo de los datos
datos_balanceados <- ovun.sample(loan_status ~ ., data = datos, method = "over")$data
```

```{r}
conteo_y2= dplyr::count(datos_balanceados, datos_balanceados$loan_status, sort = TRUE)
colnames(conteo_y2) <- c('Variable objetivo loan_status','Cantidad')

kable(conteo_y2,caption = "Cantidad de registros categorizados balanceados") %>% 
  kable_styling(full_width = F,position = "center") %>% 
  kable_minimal()
```

```{r}
print("Tabla 2. Tabla del nuevo conteo de la variable loan_status")
```

Debido a la alta cantidad de registros que existen en el dataset, se procede a usar una muestra del 8% de todo el dataset para la creación del modelo.

```{r}
n_muestra <- dim(datos_balanceados)[1]
p <- 0.08 # proporción de datos para el nuevo dataset
ix <- sample(n_muestra,size = round(n_muestra*p),
                replace = FALSE)
datos_muestra <- datos_balanceados[ix,]
```

# Scorecards

Para la creación del scorecard, se utiliza un liberia llamada "Scorecard", la cual permite mediante sus funciones poder crear el modelo de manera óptima. Como primer paso, se realiza un filtrado de los datos ya procesados anteriormente utilizando la función "var_filter". Luego, se procede a la creación de los contenedores finos por variable (o en ingles fine bins). Y luego, se obtienen los valores woe para cada registro por cada una de sus variables.

```{r}
datos_sel = var_filter(datos_muestra, "loan_status", positive = 'Incumple')
```

```{r}
bins = woebin(datos_sel, "loan_status", positive = '1')
```

```{r, results}
datos_woe = woebin_ply(datos_sel, bins)
```

Ya por último, se obtiene el objeto denominado **"Card"**, el cual nos permite obtener el score de acuerdo a los valores de las variables.

```{r}
# Se ajusta un modelo lineal
m = glm(loan_status ~ ., family = binomial(), data = datos_woe)

# Se seleccione un modelo basado en fórmulas por AIC
m_step = step(m, direction="both", trace=FALSE)

m2 = eval(m_step$call)

# Card
card = scorecard(bins, m2)

# Scord para cada registro del dataset datos_muestra
score1 = scorecard_ply(datos_muestra, card)

# Scord para cada registro del dataset datos_muestra y para variable
score2 = scorecard_ply(datos_muestra, card, only_total_score = FALSE)
```

```{r}
# Se modifican los outliers presentados en el score obtenido.
x <- score1$score   
qnt <- quantile(x, probs=c(.25, .75), na.rm = T)
caps <- quantile(x, probs=c(.05, .95), na.rm = T)
H <- 1.5 * IQR(x, na.rm = T)
x[x < (qnt[1] - H)] <- caps[1]
x[x > (qnt[2] + H)] <- caps[2]

score1_mod <- as.data.frame(x)
colnames(score1_mod) <- c("score")

```

## Analisis del modelo obtenido

Una vez obtenido el modelo que genera el score, se analiza con la siguiente gráfica el score asociado con la probabilidad de incumplimiento de pago del cliente.

```{r}
dato_fit <- fitted(m2)
plot(dato_fit,score1_mod$score, main = "Curva de score con respecto a la probabilidad de incumpliemto", xlab = "Probabilidad de incumplimiento", ylab = "Score", col = "purple")
```

```{r}
print("Figura 27. Curva de score con respecto a la probabilidad de incumpliemto")
```

En Figura 27, podemos observar que a medida que la probabilidad se vuelve 0 (Cliente cumple con el pago del crédito), el valor del score tiende a crecer. Mientras que cuando probabilidad se vuelve 1 (Cliente incumple con el pago del crédito), el score tiende a disminuir.

## Análisis de las variables empledas en el modelo

```{r}
pander(summary(m))
```

```{r}
print("Tabla 3. Tabla de resumen de las variables usadas en el modelo")
```

Por medio de la Tabla 3, identificamos las variables que hacen mas riesgosa a una persona. Estas son aquellas que tienen un p-valor menor al valor de significancia (0.05) en la columna Pr(\>\|z\|).

```{r}

respuesta <- as.data.frame(datos_muestra[1,])
```

```{r}
Nuevo_score = scorecard_ply(respuesta, card)
```

## Referencias

-   Ng Yong Kad. (2020). Credit Scoring Development Using R. 2022, 15 de ocubre 2022, de rpubs. Sitio web: https://rpubs.com/ngyongkad/scorecard

-   CRAN. (2022). Package \'scorecard\'. 2022, 15 de ocubre 2022, de Package \'scorecard\'. Sitio web: https://cran.r-project.org/web/packages/scorecard/scorecard.pdf


